[{"id":0,"href":"/VisualComputing-Showcase/workshops/workshop1/workshop_1/","title":"Creating a New Theme","section":"Workshop1","content":"Introduction #  This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment $ echo this is a command this is a command ## edit the file $ vi foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug :wq ## show it $ cat foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug $ Some Definitions #  There are a few concepts that you need to understand before creating a theme.\nSkins #  Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page #  The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\n"},{"id":1,"href":"/VisualComputing-Showcase/workshops/workshop_1/","title":"Creating a New Theme","section":"Illusions","content":"Introduction #  This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment $ echo this is a command this is a command ## edit the file $ vi foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug :wq ## show it $ cat foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug $ Some Definitions #  There are a few concepts that you need to understand before creating a theme.\nSkins #  Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page #  The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\n"},{"id":2,"href":"/VisualComputing-Showcase/workshops/workshop1/","title":"Workshop1","section":"Illusions","content":"Visual phenomena and Optical Illusions #  I. Introducción #  Las ilusiones ópticas son distorsiones de los sentidos causadas por el sistema visual, caracterizadas por una percepción que parece diferir de la realidad. Estas pueden revelar cómo el cerebro humano organiza e interpreta normalmente la estimulación sensorial y permiten estudiar las limitaciones de la percepción visual. Este tipo de \u0026ldquo;fenómenos\u0026rdquo; son adaptaciones especialmente buenas de nuestro sistema visual a situaciones de visión estándar; estas adaptaciones al depender de nuestro cerebro pueden provocar interpretaciones inadecuadas de la escena visual y dependen de la representación interna de la realidad una vez nuestros ojos han filtrado la información. Michael Bach es un científico alemán que ha investigado ampliamente el campo de la oftalmología y la percepción visual, y su sitio \u0026ldquo;Optical Illusions \u0026amp; Visual Phenomena\u0026rdquo; contiene un amplio repertorio de ilusiones ópticas que son claramente explicadas y su explicación nos acerca a entender un poco mejor de donde viene la interpretación que se da de estos fenómenos. Bach los clasifica en fenómenos de movimiento y tiempo, iluminación y contraste, color, ilusiones geométricas y angulares, entre otros. Para este trabajo se han seleccionado tres de los fenómenos/ilusiones propuestas por Bach, las cuales se analizarán en detalle y se presentará su correspondiente implementación en JavaScript utilizando la biblioteca de p5.js\nII. Contextualización #  Stereokinetic Effect #  El primer informe del fenómeno estereo cinético fue publicado en 1924 por Mussati, atribuyendo su descubrimiento a su maestro, Vittorio Benussi. Establecía que todas las percepciones de profundidad se basan en información de movimiento como fenómeno estereo cinético, y que entre los eventos que consideraba ejemplos de este efecto, estaban:\n Percibir la profundidad desde el paralaje de movimiento. Se refiere al hecho de que los objetos que se mueven a velocidad constante a lo largo del fotograma parecerán moverse en mayor proporción si se encuentran más cerca al observador. El efecto cinético de profundidad, que se refiere a la percepción tridimensional al observar las proyecciones de objetos rotando. Patrones bidimensionales que al rotar sobre el plano de una imagen evocan impresiones de profundidad.  El patrón más comúnmente estudiado del efecto estéreo cinético, referido como SKE cone, consiste en patrones circulares anidados que rotan sobre una plataforma circular. Estos círculos, al rotar alrededor de algún eje distinto de la línea de visión de quien los observa, permiten extraer la configuración tridimensional del patrón, debido a varias transformaciones ópticas que se producen. Al hacer rotar varios círculos externos sobre el eje de la plataforma circular, y círculos internos sobre un círculo interno intermedio, en sentido contrario, se puede apreciar una ilusión de un objeto tridimensional cónico, y apreciar profundidad mediante los círculos internos [Figura 2]. Si la rotación se mantiene en un solo sentido para todos los círculos internos, se tiene la impresión de un cono que apunta hacia el observador, o visto desde otra perspectiva, el interior de un cono que apunta hacia el sentido opuesto al observador [Figura 1].\nFigura 1. Efecto estereo cinético de cono, donde todos los círculos internos rotan respecto a un círculo externo, dando la impresión de un cono apuntando hacia o en sentido contrario del observador.\n Figura 2. Efecto estereo cinético de cono, donde algunos los círculos internos rotan respecto a otro círculo interno, pudiendo obtener la percepción de profundidad de un cono abierto.\n Cuando el movimiento a lo largo de los contornos de los círculos no es detectado, el patrón alcanza lo que Musatti llamó estabilidad de orientación, por lo parece que los contornos se mueven relativos a otros, lo cual a su vez evoca la percepción de una forma tridimensional, inclinada en profundidad en un ángulo consistente con su excentricidad y altura aparente y moviéndose alrededor de la línea de visión (el eje z) con componentes oscilatorios iguales en los ejes x e y.\nStroboscopic Artifacts #  El segundo fenómeno visual consiste de una rueda o disco dividida en tres componentes que inicialmente corresponden cada una a un color primario del modelo RGB (rojo, verde y azul). La rueda gira en la dirección de las manecillas del reloj y a medida que incrementa el ángulo de rotación de ésta, al igual que el retardo entre actualizaciones dado en fotogramas se pueden observar interesantes cambios en las tonalidades de la misma, además de la \u0026ldquo;dirección\u0026rdquo; del movimiento. En este fenómeno, se pueden evidenciar momentos clave, que aparecen en ángulos de 60°, y más claramente 120°, donde la rueda toma valores similares al gris, debido a que cada sector alterna rápidamente entre los tres colores principales, cuya mezcla da como resultado el color evidenciado. Además, si se aumenta el ángulo 5°, parece surgir una \u0026ldquo;hélice\u0026rdquo; que gira hacia la derecha, donde cada pala está compuesta de los tres colores complementarios de los principales (magenta, cian y amarillo), por otro lado, si se disminuye en 5°, parece que la hélice gira hacia atrás.\nBach explica tal fenómeno desde la perspectiva del movimiento en las pantallas de ordenador, que cuando se trata de un movimiento rápido sufren del efecto estroboscópico o también denominado aliasing temporal. El aliasing se puede explicar bajo el escenario de que cuando se ve una imagen digital, un dispositivo de visualización, los ojos y el cerebro realizan una reconstrucción; si los datos de la imagen se procesan de alguna manera durante el muestreo o la reconstrucción, la imagen reconstruida diferirá de la imagen original, y se verá un alias que suele superponer al original (este efecto se evidencia comúnmente en el muestreo de señales). Por su parte, el efecto estroboscópico se produce cuando el movimiento rotativo continuo u otro movimiento cíclico se representa mediante una serie de muestras cortas o instantáneas (en contraposición a una vista continua) a una frecuencia de muestreo cercana al periodo del movimiento. Esta es la causa del \u0026ldquo;efecto rueda de carreta\u0026rdquo;, que Bach abarca también en su repertorio, llamado así porque en los videos, las ruedas (como las de los carros de caballos) a veces parecen girar hacia atrás. Para que se produzca tal efecto, es necesario que la pantalla se presente de forma discontinua: puede que no sea visible, pero la rueda (o lo que se presente en la pantalla) se mueve a \u0026ldquo;tirones\u0026rdquo;; si estas \u0026ldquo;sacudidas\u0026rdquo; se producen con suficiente rapidez (por ejemplo, 20 veces por segundo, o similar al caso de nuestro ejemplo), nuestro sistema visual interpola las posiciones que faltan. Esta interpolación se basa en el principio del \u0026ldquo;vecino más cercano\u0026rdquo; y si el desplazamiento del radio de la rueda de un fotograma a otro es tan grande que está más cerca del (antiguo) radio siguiente que del (antiguo) original, nuestro sistema visual asume la dirección de movimiento opuesta.\nBach también menciona la importancia de la frecuencia de fotogramas en el movimiento. El disco no gira suavemente, sino que se presenta en cuadros fijos que se suceden rápidamente, cada uno con un ángulo de rotación diferente, lo que produce la percepción de un movimiento suave, también llamado \u0026ldquo;Fenómeno Phi\u0026rdquo; de Wertheimer. Sin embargo, este movimiento depende en gran medida de la tasa de fotogramas, que para el caso predeterminado es de 60 cuadros mostrados por segundo y también entra en juego otro aspecto: la tasa de fotogramas del monitor o la pantalla. Según esto, entonces, lo que se puede apreciar exactamente depende de la interacción de las dos tasas de fotogramas y del incremento del ángulo, donde en variados casos según la configuración se puede evidenciar la \u0026ldquo;mezcla\u0026rdquo; de los colores, por el solapamiento de las secciones, además de los efectos ya mencionados.\nMoiré Patterns #  Moiré es una palabra francesa que significa muaré en el español y es una textura o tipo de tejido que genera una visión sobre la seda simulando un entorno acuático y ondulado debido a la manera de su fabricación, que es la superposición de dos textiles húmedos generando un patrón cuando la seda se seca.\nEsta ilusión optica conocida como Moiré patterns o patrones muaré hace referencia a la superposición de dos patrones similares que están compuestos por rayas opacas ó de color junto con un espacio transaparente. Al encontrarse diferencias en los patrones, la colocación de los mismos, movimientos de rotación o desplazamiento y otros aspectos como aceleración o formatura, es posible generar una especie de bandas oscuras móviles conocidas como moirés. Este efecto no es simplemente aludido en el arte y la animación, sino que, tiene aplicaciones científicas en los campos de matemática y física en donde surgen cálculos con respecto a las formas, rotaciones, aceleraciones, desplazamientos, interferencia de ondas, entre otros más.\nFigura 4. Moirés generados por la rotación de uno de dos patrones de líneas paralelas negras. Imagen extraída de: Wikipedia\n La explicación a detalle de esta ilusión consiste en un fenómeno relativo a la luz y la superposición, pues la luz impacta a ambos patrones que permiten que esta pueda pasar o quedar bloqueada según la forma y/o el color o transparencia en el que se encuentre impactando. Esto genera una multiplicación en las razones de transmitancia de luz y dos frecuencias que a la vista parecen distintas.\nFigura 5. Moirés generados el movimiento horizontal de un patron de círculos concéntricos.\n III. Resultados #  La implementación utilizando p5.js realizada para los casos anteriores se muestra a continuación:\np5-instance-div markdown  const frame_rate = 60;   let show_crater_cb;  let show_crater = true;  let slider_label;   function setup() {  createCanvas(500, 500);  show_crater_cb = createCheckbox(\u0026#39;show crater\u0026#39;, show_crater);  show_crater_cb.changed(() =\u0026gt; {  show_crater = show_crater_cb.checked();  });  frames_slider = createSlider(0.5, 5, 1, 0.25);  frames_slider.position(180, 515);  frames_slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  slider_label = createSpan(\u0026#39;speed\u0026#39;);  slider_label.position(135, 513);  frameRate(frame_rate);  }   function draw() {  background(220);   let difference = 40;  let inner_diameter = 40;   const outer_circles = 11;  const start = inner_diameter + outer_circles * difference;  const end = inner_diameter;   noStroke();   let posX = 0, posY = 0;  let referenceX = width / 2;  let referenceY = height / 2;   let t, outer_coeff, inner_coef;   for (let diameter = start, index = 0; diameter \u0026gt;= end; diameter -= difference, index++) {  fill(index % 2 === 0 ? color(\u0026#39;blue\u0026#39;) : color(\u0026#39;yellow\u0026#39;));  let orientation = index \u0026gt; 6 \u0026amp;\u0026amp; show_crater ? -1 : 1;  outer_coeff = orientation * index * difference / 2;  t = frameCount * frames_slider.value() / frame_rate;  posX = referenceX + outer_coeff * cos(t);  posY = referenceY + outer_coeff * sin(t);  if (index == 6 \u0026amp;\u0026amp; show_crater) {  inner_coef = diameter / 2 + difference;  referenceX = posX + inner_coef * cos(t);  referenceY = posY + inner_coef * sin(t);  }  circle(posX, posY, diameter);  }  }    \n         \"  --      const frame_rate = 60; let show_crater_cb; let show_crater = true; let slider_label; function setup() { createCanvas(500, 500); show_crater_cb = createCheckbox(\u0026#39;show crater\u0026#39;, show_crater); show_crater_cb.changed(() =\u0026gt; { show_crater = show_crater_cb.checked(); }); frames_slider = createSlider(0.5, 5, 1, 0.25); frames_slider.position(180, 515); frames_slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); slider_label = createSpan(\u0026#39;speed\u0026#39;); slider_label.position(135, 513); frameRate(frame_rate); } function draw() { background(220); let difference = 40; let inner_diameter = 40; const outer_circles = 11; const start = inner_diameter \u0026#43; outer_circles * difference; const end = inner_diameter; noStroke(); let posX = 0, posY = 0; let referenceX = width / 2; let referenceY = height / 2; let t, outer_coeff, inner_coef; for (let diameter = start, index = 0; diameter \u0026gt;= end; diameter -= difference, index\u0026#43;\u0026#43;) { fill(index % 2 === 0 ? color(\u0026#39;blue\u0026#39;) : color(\u0026#39;yellow\u0026#39;)); let orientation = index \u0026gt; 6 \u0026amp;\u0026amp; show_crater ? -1 : 1; outer_coeff = orientation * index * difference / 2; t = frameCount * frames_slider.value() / frame_rate; posX = referenceX \u0026#43; outer_coeff * cos(t); posY = referenceY \u0026#43; outer_coeff * sin(t); if (index == 6 \u0026amp;\u0026amp; show_crater) { inner_coef = diameter / 2 \u0026#43; difference; referenceX = posX \u0026#43; inner_coef * cos(t); referenceY = posY \u0026#43; inner_coef * sin(t); } circle(posX, posY, diameter); } }      \"  p5-instance-div markdown let angle = 0; let frames; let colorp1, colorp2, colorp3; let rotation_angle; function setup() {  createCanvas(500, 500);  frames_slider = createSlider(5, 120, 60, 5);  frames_slider.position(180, 40);  frames_slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  ellipseMode(CENTER);  rotation_angle = createP().position(25, 5);  frames = createP().position(180, 5);  slider = createSlider(0, 360, 0, 5);  slider.position(20, 40);  slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  createP(\u0026#39;Colors:\u0026#39;).position(25, 55).style(\u0026#39;font-size: 15px\u0026#39;);  colorp1 = createColorPicker([0, 255, 0]).position(20, 95);  colorp2 = createColorPicker([0, 0, 255]).position(20, 135);  colorp3 = createColorPicker([255, 0, 0]).position(20, 175); }   function draw() {  background(200);  noStroke();  translate(width/2, height/2);  rotate(angle);  fill(colorp1.color());  arc(0, 0, width/2, height/2, 0, 2*PI/3);  fill(colorp2.color());  arc(0, 0, width/2, height/2, 2*PI/3, 4*PI/3);  fill(colorp3.color());  arc(0, 0, width/2, height/2, 4*PI/3, 2*PI);   angle += radians(slider.value());  frameRate(frames_slider.value());  rotation_angle.html(\u0026#39;Rotation angle: \u0026#39; + slider.value());  frames.html(\u0026#39;Frame rate: \u0026#39; + frames_slider.value()); }    \n         \"  --      let angle = 0; let frames; let colorp1, colorp2, colorp3; let rotation_angle; function setup() { createCanvas(500, 500); frames_slider = createSlider(5, 120, 60, 5); frames_slider.position(180, 40); frames_slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); ellipseMode(CENTER); rotation_angle = createP().position(25, 5); frames = createP().position(180, 5); slider = createSlider(0, 360, 0, 5); slider.position(20, 40); slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); createP(\u0026#39;Colors:\u0026#39;).position(25, 55).style(\u0026#39;font-size: 15px\u0026#39;); colorp1 = createColorPicker([0, 255, 0]).position(20, 95); colorp2 = createColorPicker([0, 0, 255]).position(20, 135); colorp3 = createColorPicker([255, 0, 0]).position(20, 175); } function draw() { background(200); noStroke(); translate(width/2, height/2); rotate(angle); fill(colorp1.color()); arc(0, 0, width/2, height/2, 0, 2*PI/3); fill(colorp2.color()); arc(0, 0, width/2, height/2, 2*PI/3, 4*PI/3); fill(colorp3.color()); arc(0, 0, width/2, height/2, 4*PI/3, 2*PI); angle \u0026#43;= radians(slider.value()); frameRate(frames_slider.value()); rotation_angle.html(\u0026#39;Rotation angle: \u0026#39; \u0026#43; slider.value()); frames.html(\u0026#39;Frame rate: \u0026#39; \u0026#43; frames_slider.value()); }      \"  p5-instance-div markdown let x = 0; let colorp1, colorp2; let increase = 0;  function setup() {   createCanvas(500, 500);  rectMode(CENTER);  colorp1 = createColorPicker([32, 162, 32]).position(20, 25);  colorp2 = createColorPicker([0, 0, 255]).position(75, 25);  slider = createSlider(0, 2, 0, 0.25);  slider.position(150, 25);  slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  }  function draw() {   background(220);   increase = slider.value();   for (let i = 0; i \u0026lt; 400; i += 20) {   stroke(colorp2.color());  strokeWeight(4);  ellipse(x, 250, i - 380, i - 380);   noFill();  stroke(colorp1.color());  strokeWeight(4);  ellipse(250, 250, i, i);   }  if (x \u0026gt; width) {   x = 0;   } else {   x = x + increase;  } }    \n          \"  --      let x = 0; let colorp1, colorp2; let increase = 0; function setup() { createCanvas(500, 500); rectMode(CENTER); colorp1 = createColorPicker([32, 162, 32]).position(20, 25); colorp2 = createColorPicker([0, 0, 255]).position(75, 25); slider = createSlider(0, 2, 0, 0.25); slider.position(150, 25); slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); } function draw() { background(220); increase = slider.value(); for (let i = 0; i \u0026lt; 400; i \u0026#43;= 20) { stroke(colorp2.color()); strokeWeight(4); ellipse(x, 250, i - 380, i - 380); noFill(); stroke(colorp1.color()); strokeWeight(4); ellipse(250, 250, i, i); } if (x \u0026gt; width) { x = 0; } else { x = x \u0026#43; increase; } }      \"   Creating a New Theme  Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme. We\u0026rsquo;ll start with creating a new site with a very basic template.   Moire Patterns  Ramp Aftereffect # a. p5-instance-div markdown let x = 0; let colorp1, colorp2; let increase = 0; function setup() { createCanvas(500, 500); rectMode(CENTER); colorp1 = createColorPicker([32, 162, 32]).position(20, 25); colorp2 = createColorPicker([0, 0, 255]).position(75, 25); slider = createSlider(0, 2, 0, 0.25); slider.position(150, 25); slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); } function draw() { background(220); increase = slider.value(); for (let i = 0; i \u0026lt; 400; i += 20) { stroke(colorp2.   Stereokinetic Effect  Stereokinetic Effect # El efecto estereocinético consiste en patrones circulares anidados que rotan sobre una plataforma circular. Estos círculos, al rotar alrededor de algún eje distinto de la línea de visión de quien los observa, permiten extraer la configuración tridimensional del patrón, debido a varias transformaciones ópticas que se producen. En el ejemplo siguiente, podemos observar cómo al hacer rotar varios círculos externos sobre el eje de la plataforma circular, y círculos internos sobre un círculo interno intermedio, en sentido contrario, se puede apreciar una ilusión de un objeto tridimensional, y apreciar profundidad mediante los círculos internos.   Stroboscopic Artifacts  Stroboscopic Artifacts # p5-instance-div markdown let angle = 0; let frames; let colorp1, colorp2, colorp3; let rotation_angle; function setup() { createCanvas(500, 500); frames_slider = createSlider(5, 120, 60, 5); frames_slider.position(180, 40); frames_slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); ellipseMode(CENTER); rotation_angle = createP().position(25, 5); frames = createP().position(180, 5); slider = createSlider(0, 360, 0, 5); slider.position(20, 40); slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); createP(\u0026#39;Colors:\u0026#39;).position(25, 55).style(\u0026#39;font-size: 15px\u0026#39;); colorp1 = createColorPicker([0, 255, 0]).   -- IV. Conclusiones #  Para concluir, podemos resaltar en nuestras investigaciones que el campo de ilusiones ópticas es sumamente extenso y rico en información. Los límites en la generación de ilusiones son inexistentes y este informe presenta solo 3 tipos de ilusiones que pueden ser replicadas y visualizadas en una infinidad de experimentos distintos.\nComo trabajo futuro podemos resaltar aplicaciones interesantes de las anteriores ilusiones ópticas, como la impresión de imágenes con color, procesamiento y medición de deformaciones en imágenes y visualización de imágenes en pantallas y dispositivos electrónicos.\nIV. Referencias #   Bach, M. (2022). 148 Visual Phenomena \u0026amp; Optical Illusions. Michael Bach Bach \u0026amp; Poloschek (2006) Optical Illusions Primer. Michael Bach Proffitt DR, Rock I, Hecht H, Schubert J. Stereokinetic effect and its relation to the kinetic depth effect. J Exp Psychol Hum Percept Perform. 1992 Feb;18(1):3-21. doi: 10.1037//0096-1523.18.1.3. PMID: 1532192.  "},{"id":3,"href":"/VisualComputing-Showcase/workshops/workshop2/","title":"Workshop2","section":"Illusions","content":"Texture Mapping and \u0026hellip; #  I. Introducción #  El mapeo de texturas es el método con el cual se realiza el detallado de color a un objeto 3D. Actualmente, se han desarrollado mapeos más complejos implicando diferentes tipos de transformaciones y polígonos como el mapeo de reflexión, relieve, entre otros.\nEl proceso consiste en la obtención de una imagen mediante fotografía digital o escaneo y su manipulación mediante software para ser utilizada. Posteriormente, la aplicación es el mapeo de vértices del polígono a una coordenada de textura. El mapeado UV consiste en el mapeado de un plano 2D a un tríangulo, ubicando los tres vertices del tríangulo en la imagen, con coordenadas normalizadas en la imagen y calculando los puntos interiores utilizando coordenadas báricentricas, se presentará su correspondiente implementación bajo nivel junto con mapeos de medio y alto nivel en JavaScript utilizando la biblioteca de p5.js y WEBGL.\nII. Contextualización #  Mapeo de Alto Nivel #  El primer mapeo de textura consiste en una esfera (sólido de revolución y no polígono) y una imagen a alto nivel mediante el uso de las funciones texture() y sphere().\nMapeo de Medio Nivel #  El segundo mapeo de textura consiste en una esfera (sólido de revolución y no polígono) y una imagen de la tierra [figura 1] a medio nivel mediante el uso de las funciones texture(), beginShape() y endShape().\nFigura 1. Plano 2D de la tierra.\n Para realizar la esfera, utilizamos los conceptos de mapeo entre longitud/latitud en un plano 2D a la esfera utilizando ángulos.\nLos valores de longitud y latitud estarán:\n $Long \\in [0^o, 360^o].$ $Lat \\in [0^o, 180^o].$  Buscamos mapear los valores de $(r,lat,long) \\arrow (x,y,z)$.\n $x = r sin(lat) cos(long)$ $y = r sin(lat) sin(long)$ $z = r cos(lat)$  p5-instance-div markdown  const globe = [];  const r = 200;  const total = 25;  let angleX = 0;  let angleY = 0;   function setup() {  createCanvas(500, 500, WEBGL);  noFill();  strokeWeight(2);  stroke(200);   for (let i = 0; i \u0026lt; total + 1; i++) {  globe[i] = [];  const lat = map(i, 0, total, 0, PI);  for (let j = 0; j \u0026lt; total + 1; j++) {  const lon = map(j, 0, total, 0, TWO_PI);  const x = r * sin(lat) * cos(lon);  const y = r * sin(lat) * sin(lon);  const z = r * cos(lat);  globe[i][j] = createVector(x, y, z);  }  }  }   function draw() {  background(51);  rotateX(angleX);  rotateY(angleY);   for (let i = 0; i \u0026lt; total; i++) {  beginShape(TRIANGLE_STRIP);  for (let j = 0; j \u0026lt; total + 1; j++) {  const v1 = globe[i][j];  vertex(v1.x, v1.y, v1.z);  const v2 = globe[i + 1][j];  vertex(v2.x, v2.y, v2.z);  }  endShape();  }   angleX += 0.005;  angleY += 0.006;  }          const globe = []; const r = 200; const total = 25; let angleX = 0; let angleY = 0; function setup() { createCanvas(500, 500, WEBGL); noFill(); strokeWeight(2); stroke(200); for (let i = 0; i \u0026lt; total \u0026#43; 1; i\u0026#43;\u0026#43;) { globe[i] = []; const lat = map(i, 0, total, 0, PI); for (let j = 0; j \u0026lt; total \u0026#43; 1; j\u0026#43;\u0026#43;) { const lon = map(j, 0, total, 0, TWO_PI); const x = r * sin(lat) * cos(lon); const y = r * sin(lat) * sin(lon); const z = r * cos(lat); globe[i][j] = createVector(x, y, z); } } } function draw() { background(51); rotateX(angleX); rotateY(angleY); for (let i = 0; i \u0026lt; total; i\u0026#43;\u0026#43;) { beginShape(TRIANGLE_STRIP); for (let j = 0; j \u0026lt; total \u0026#43; 1; j\u0026#43;\u0026#43;) { const v1 = globe[i][j]; vertex(v1.x, v1.y, v1.z); const v2 = globe[i \u0026#43; 1][j]; vertex(v2.x, v2.y, v2.z); } endShape(); } angleX \u0026#43;= 0.005; angleY \u0026#43;= 0.006; }      \"  Figura 2. Esfera construida a bajo nivel.\n Por último, es necesario establecer el modo de textura normalizado y dividir nuestros valores de longitud (coordenada x) y latitud (coordenada y) entre el número total de vértices para darles un valor entre 0 y 1.\nMapeo de Bajo Nivel #  El tercer mapeo de textura consiste en un plano 2D y una imagen de \u0026hellip; a bajo nivel mediante el uso de las funciones beginShape() y endShape() y la librería de cuadrícula p5.quadrille.js.\nIII. Resultados #  La implementación utilizando p5.js realizada para los casos anteriores se muestra a continuación:\np5-instance-div markdown  let angleX = 0;  let angleY = 0;   function preload() {  sun = loadImage(\u0026#39;https://lh6.googleusercontent.com/MKWuIXLwcIXgwmrKrnjgCFEjna_8kFePKfWJlhOQLpBZ3pagPVPjxyHxZPHs2CTGMm1sdKLx_WGkjVhnDF_L9EQbata6o2Cw0dtIvNYz-yQG_YJXNfpWff_HbdsNtqkWAia6jwG7aLWDbJbn6w\u0026#39;);  }   function setup() {  createCanvas(500, 500, WEBGL);  noFill();  strokeWeight(2);  stroke(200);  }   function draw() {  background(51);  rotateX(angleX);  rotateY(angleY);   textureMode(NORMAL);  texture(earth);   sphere(200);   angleX += 0.005;  angleY += 0.006;  }          let angleX = 0; let angleY = 0; function preload() { sun = loadImage(\u0026#39;https://lh6.googleusercontent.com/MKWuIXLwcIXgwmrKrnjgCFEjna_8kFePKfWJlhOQLpBZ3pagPVPjxyHxZPHs2CTGMm1sdKLx_WGkjVhnDF_L9EQbata6o2Cw0dtIvNYz-yQG_YJXNfpWff_HbdsNtqkWAia6jwG7aLWDbJbn6w\u0026#39;); } function setup() { createCanvas(500, 500, WEBGL); noFill(); strokeWeight(2); stroke(200); } function draw() { background(51); rotateX(angleX); rotateY(angleY); textureMode(NORMAL); texture(earth); sphere(200); angleX \u0026#43;= 0.005; angleY \u0026#43;= 0.006; }      \"  Figura 3. Esfera mapaeada con la función del sol.\n  p5-instance-div markdown  const globe = [];  const r = 200;  const total = 50;  let angleX = 0;  let angleY = 0;   function preload() {  earth = loadImage(\u0026#39;https://lh6.googleusercontent.com/IwEkyWS6TCXKxJWlsIaylCZT53k3i6nhXs2xo6Fduap28MgLZMyypiK9KHvJDi7APkDkzh5-80y3i1PdPL_XeCn72HspV9z_jTThXpG3VCee0NUoJ_RBezRKSBWXn6YtgbBKPhL23x1ruQImzQ\u0026#39;);  }   function setup() {  createCanvas(500, 500, WEBGL);  noFill();  strokeWeight(2);  stroke(200);   for (let i = 0; i \u0026lt; total + 1; i++) {  globe[i] = [];  const lat = map(i, 0, total, 0, PI);  for (let j = 0; j \u0026lt; total + 1; j++) {  const lon = map(j, 0, total, 0, TWO_PI);  const x = r * sin(lat) * cos(lon);  const y = r * sin(lat) * sin(lon);  const z = r * cos(lat);  globe[i][j] = createVector(x, y, z);  }  }  }   function draw() {  background(51);  rotateX(angleX);  rotateY(angleY);   textureMode(NORMAL);  texture(earth);  scale(-1,1);   for (let i = 0; i \u0026lt; total; i++) {  beginShape(TRIANGLE_STRIP);  for (let j = 0; j \u0026lt; total + 1; j++) {  const v1 = globe[i][j];  vertex(v1.x, v1.y, v1.z, j / total, i / total);  const v2 = globe[i + 1][j];  vertex(v2.x, v2.y, v2.z, j / total, (i + 1) / total);  }  endShape();  }   angleX += 0.005;  angleY += 0.006;  }          const globe = []; const r = 200; const total = 50; let angleX = 0; let angleY = 0; function preload() { earth = loadImage(\u0026#39;https://lh6.googleusercontent.com/IwEkyWS6TCXKxJWlsIaylCZT53k3i6nhXs2xo6Fduap28MgLZMyypiK9KHvJDi7APkDkzh5-80y3i1PdPL_XeCn72HspV9z_jTThXpG3VCee0NUoJ_RBezRKSBWXn6YtgbBKPhL23x1ruQImzQ\u0026#39;); } function setup() { createCanvas(500, 500, WEBGL); noFill(); strokeWeight(2); stroke(200); for (let i = 0; i \u0026lt; total \u0026#43; 1; i\u0026#43;\u0026#43;) { globe[i] = []; const lat = map(i, 0, total, 0, PI); for (let j = 0; j \u0026lt; total \u0026#43; 1; j\u0026#43;\u0026#43;) { const lon = map(j, 0, total, 0, TWO_PI); const x = r * sin(lat) * cos(lon); const y = r * sin(lat) * sin(lon); const z = r * cos(lat); globe[i][j] = createVector(x, y, z); } } } function draw() { background(51); rotateX(angleX); rotateY(angleY); textureMode(NORMAL); texture(earth); scale(-1,1); for (let i = 0; i \u0026lt; total; i\u0026#43;\u0026#43;) { beginShape(TRIANGLE_STRIP); for (let j = 0; j \u0026lt; total \u0026#43; 1; j\u0026#43;\u0026#43;) { const v1 = globe[i][j]; vertex(v1.x, v1.y, v1.z, j / total, i / total); const v2 = globe[i \u0026#43; 1][j]; vertex(v2.x, v2.y, v2.z, j / total, (i \u0026#43; 1) / total); } endShape(); } angleX \u0026#43;= 0.005; angleY \u0026#43;= 0.006; }      \"  Figura 4. Esfera mapaeada con la imagen de la tierra.\n   -- IV. Conclusiones #  Para concluir, podemos resaltar en nuestras investigaciones que el campo de mapeo de texturas ha sido apropiado para investigaciones y desarrollos más complejos, para entender este proceso es necesario entender las bases y el bajo nivel de los gráficos, ádemas de conceptos matemáticos claves como sistemas de coordenadas, geoetría y otros involucrados en rasterización. Como trabajo futuro se puede proponer el mapeo de texturas de medio y bajo nivel a súper geometrías y el desarrollo de estas a nivel matemático debido al alto nivel de complejidad de estas figuras. Esta investigación se ha realizado de manera transversal por los distintos niveles de mapeo, afianzando los conocimientos y conceptos, convirtiéndose así en una buena ejemplificación práctica del mapeo de texturas.\nIV. Referencias #   Wikipedia contributors. (2022, 22 abril). Texture mapping. Wikipedia. https://en.wikipedia.org/wiki/Texture_mapping. Wikipedia Wikipedia contributors. (2022b, mayo 16). Spherical coordinate system. Wikipedia. https://en.wikipedia.org/wiki/Spherical_coordinate_system Wikipedia  "},{"id":4,"href":"/VisualComputing-Showcase/workshops/workshop1/moire_patterns/","title":"Moire Patterns","section":"Workshop1","content":"Ramp Aftereffect #  a.  p5-instance-div markdown let x = 0; let colorp1, colorp2; let increase = 0;  function setup() {   createCanvas(500, 500);  rectMode(CENTER);  colorp1 = createColorPicker([32, 162, 32]).position(20, 25);  colorp2 = createColorPicker([0, 0, 255]).position(75, 25);  slider = createSlider(0, 2, 0, 0.25);  slider.position(150, 25);  slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  }  function draw() {   background(220);   increase = slider.value();   for (let i = 0; i \u0026lt; 400; i += 20) {   stroke(colorp2.color());  strokeWeight(4);  ellipse(x, 250, i - 380, i - 380);   noFill();  stroke(colorp1.color());  strokeWeight(4);  ellipse(250, 250, i, i);   }  if (x \u0026gt; width) {   x = 0;   } else {   x = x + increase;  } }             \"  "},{"id":5,"href":"/VisualComputing-Showcase/workshops/workshop1/stereokinetic_effect/","title":"Stereokinetic Effect","section":"Workshop1","content":"Stereokinetic Effect #  El efecto estereocinético consiste en patrones circulares anidados que rotan sobre una plataforma circular. Estos círculos, al rotar alrededor de algún eje distinto de la línea de visión de quien los observa, permiten extraer la configuración tridimensional del patrón, debido a varias transformaciones ópticas que se producen. En el ejemplo siguiente, podemos observar cómo al hacer rotar varios círculos externos sobre el eje de la plataforma circular, y círculos internos sobre un círculo interno intermedio, en sentido contrario, se puede apreciar una ilusión de un objeto tridimensional, y apreciar profundidad mediante los círculos internos.  p5-instance-div markdown  const frame_rate = 60;   let show_crater_cb;  let show_crater = true;  let slider_label;   function setup() {  createCanvas(500, 500);  show_crater_cb = createCheckbox(\u0026#39;show crater\u0026#39;, show_crater);  show_crater_cb.changed(() =\u0026gt; {  show_crater = show_crater_cb.checked();  });  frames_slider = createSlider(0.5, 5, 1, 0.25);  frames_slider.position(180, 515);  frames_slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  slider_label = createSpan(\u0026#39;speed\u0026#39;);  slider_label.position(135, 513);  frameRate(frame_rate);  }   function draw() {  background(220);   let difference = 40;  let inner_diameter = 40;   const outer_circles = 11;  const start = inner_diameter + outer_circles * difference;  const end = inner_diameter;   noStroke();   let posX = 0, posY = 0;  let referenceX = width / 2;  let referenceY = height / 2;   let t, outer_coeff, inner_coef;   for (let diameter = start, index = 0; diameter \u0026gt;= end; diameter -= difference, index++) {  fill(index % 2 === 0 ? color(\u0026#39;blue\u0026#39;) : color(\u0026#39;yellow\u0026#39;));  let orientation = index \u0026gt; 6 \u0026amp;\u0026amp; show_crater ? -1 : 1;  outer_coeff = orientation * index * difference / 2;  t = frameCount * frames_slider.value() / frame_rate;  posX = referenceX + outer_coeff * cos(t);  posY = referenceY + outer_coeff * sin(t);  if (index == 6 \u0026amp;\u0026amp; show_crater) {  inner_coef = diameter / 2 + difference;  referenceX = posX + inner_coef * cos(t);  referenceY = posY + inner_coef * sin(t);  }  circle(posX, posY, diameter);  }  }             \"  "},{"id":6,"href":"/VisualComputing-Showcase/workshops/workshop1/stroboscopic_artifacts/","title":"Stroboscopic Artifacts","section":"Workshop1","content":"Stroboscopic Artifacts #  p5-instance-div markdown let angle = 0; let frames; let colorp1, colorp2, colorp3; let rotation_angle; function setup() {  createCanvas(500, 500);  frames_slider = createSlider(5, 120, 60, 5);  frames_slider.position(180, 40);  frames_slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  ellipseMode(CENTER);  rotation_angle = createP().position(25, 5);  frames = createP().position(180, 5);  slider = createSlider(0, 360, 0, 5);  slider.position(20, 40);  slider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;);  createP(\u0026#39;Colors:\u0026#39;).position(25, 55).style(\u0026#39;font-size: 15px\u0026#39;);  colorp1 = createColorPicker([0, 255, 0]).position(20, 95);  colorp2 = createColorPicker([0, 0, 255]).position(20, 135);  colorp3 = createColorPicker([255, 0, 0]).position(20, 175); }   function draw() {  background(200);  noStroke();  translate(width/2, height/2);  rotate(angle);  fill(colorp1.color());  arc(0, 0, width/2, height/2, 0, 2*PI/3);  fill(colorp2.color());  arc(0, 0, width/2, height/2, 2*PI/3, 4*PI/3);  fill(colorp3.color());  arc(0, 0, width/2, height/2, 4*PI/3, 2*PI);   angle += radians(slider.value());  frameRate(frames_slider.value());  rotation_angle.html(\u0026#39;Rotation angle: \u0026#39; + slider.value());  frames.html(\u0026#39;Frame rate: \u0026#39; + frames_slider.value()); }             \"  "},{"id":7,"href":"/VisualComputing-Showcase/workshops/","title":"Illusions","section":"Introduction","content":" Workshop 1 Workshop 2  "},{"id":8,"href":"/VisualComputing-Showcase/members/","title":"Members","section":"Introduction","content":"Members #  Felipe Rojas Cendales #  Estudiante de octavo semestre en la carrera de ingeniería de sistemas, tengo 21 años. Apasionado por el desarrollo de software y la línea de proyectos. Tengo poco conocimiento acerca de animaciones y computación visual, sin embargo, es un tema que me llama mucho la atención.\nEn mi tiempo libre me dedico a mi familia, mis amigos, ver deportes como el automovilismo y practicar otros como una forma de relajación.\nNicolas Arevalo Rodriguez #  Soy un estudiante de octava matricula de ingenieria de sistemas y computación, tengo 23 años. Me interesa el desarrollo web, principalmente el front end y espero adquirir la experiencia para implementar animaciones, ilusiones visuales y efectos visualmente atractivos en mis aplicaciones. En mi tiempo libre me dedico a ver series (animadas), jugar en linea con amigos o ver videos/escuchar podcasts sobre temas de mi interés.\nJonathan Lopez Castellanos #  Estudiante de octavo semestre en la carrera de ingeniería de sistemas, tengo 21 años. Apasionado por la arquitectura de software y el diseño del mismo.\nEn mi tiempo libre me dedico a proyectos de software propios, ver series en streaming y escuchar buena musiquita.\n"}]